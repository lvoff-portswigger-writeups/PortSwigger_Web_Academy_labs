## Lab Information
Topic: NoSQL Injection  
Difficulty: Apprentice

## Lab Description
The lab features a login endpoint backed by MongoDB that is vulnerable to NoSQL operator injection. User input is directly embedded in the query object, enabling attackers to inject MongoDB operators such as `$ne` and `$where`. This allows discovery of internal document fields and extraction of sensitive values like `resetToken`. Using this token, the attacker can reset Carlos’s password and log in.

## Vulnerability Analysis
The vulnerability is caused by NoSQL operator injection.
The backend accepts JSON input and passes it directly to MongoDB. MongoDB allows logical operators and `$where` clauses that execute JavaScript-like expressions. Because the server does not enforce types or block operators, injected expressions can:
- Change query logic.
- Use `$where` to execute boolean expressions.
- Read arbitrary fields via `Object.keys(this)` and regex.
- Extract sensitive values through blind character-by-character matching.

## Exploitation Steps
1. Identified `/login` as injection point.
2. Observed “Account locked” message for `username=carlos`.
3. Injected: `{"username":"carlos","password":{"$ne":"invalid"}}` → still “Account locked”.
4. Injected `$where`:
   - `$where: "0"` → invalid credentials  
   - `$where: "1"` → account locked  
   → Confirms `$where` is injectable.
5. Brute‑forced field names with:
   ```
   Object.keys(this)[i].match('^.{j}x.*')
   ```
6. Extracted keys: `id`, `username`, `password`, `email`, `resetToken`.
7. Extracted `resetToken` using:
   ```
   this.resetToken.match('^.{$i}$c.*')
   ```
8. Determined correct characters by response length (209 vs 151).
9. Used the recovered token in `/forgot-password?resetToken=<token>`.
10. Reset Carlos's password and logged in.

## AppSec Perspective
### What the underlying code might be
```javascript
app.post('/login', (req, res) => {
    const body = req.body;
    db.users.findOne(body).then(user => {
        if (!user) return res.send("Invalid username or password");
        if (user.locked) return res.send("Account locked: please reset your password");
        req.session.user = user;
        res.redirect('/my-account');
    });
});
```

### Security issues enabling exploitation
- Direct use of untrusted user input in database queries, without sanitization or structural validation.
- Lack of strict type enforcement, allowing attacker-controlled objects or expressions to be interpreted as query logic (user input influences the query structure instead of being treated as literal data).
- Absence of schema validation, enabling malformed or operator-based payloads (e.g., $ne, $where, property access such as this.password[i]).

### How to fix it
```javascript
app.post('/login', (req, res) => {
    const { username, password } = req.body;

    if (typeof username !== "string" || typeof password !== "string") { // Strict type checking
        return res.status(400).send("Invalid input");
    }

    db.users.findOne({ username: { $eq: username } }).then(user => {  // Use of `$eq` to avoid implicit operator injection
        if (!user) return res.status(401).send("Invalid username or password");
        if (user.locked) return res.send("Account locked: please reset your password");

        if (!verifyPassword(password, user.passwordHash)) {
            return res.status(401).send("Invalid username or password");
        }

        req.session.user = user;
        res.redirect('/my-account');
    });
});
```

**Or even better using authentication libraries**
```javascript
const Joi = require('joi');
const passport = require('passport');
const LocalStrategy = require('passport-local').Strategy;
const bcrypt = require('bcrypt');

// Validation schema to prevent operator injection
const loginSchema = Joi.object({
    username: Joi.string().min(1).max(50).required(),
    password: Joi.string().min(1).max(200).required()
});

// Passport authentication strategy
passport.use('safe-login', new LocalStrategy(async (username, password, done) => {
    try {
        const user = await db.users.findOne({ username: username }).exec(); // safe lookup
        if (!user) return done(null, false);

        if (user.locked) {
            return done(null, false, { message: "Account locked: please reset your password" });
        }

        const valid = await bcrypt.compare(password, user.passwordHash);
        if (!valid) return done(null, false);

        return done(null, user);
    } catch (err) {
        return done(err);
    }
}));

app.post('/login', async (req, res, next) => {
    // Validate request body
    const { error } = loginSchema.validate(req.body);
    if (error) return res.status(400).send("Invalid input");

    // Delegate authentication to the Passport middleware
    passport.authenticate('safe-login', (err, user, info) => {
        if (err) return next(err);
        if (!user) {
            if (info?.message) return res.send(info.message);
            return res.status(401).send("Invalid username or password");
        }

        req.logIn(user, (err) => {
            if (err) return next(err);
            return res.redirect('/my-account');
        });
    })(req, res, next);
});
```

## Key Takeaways
### Lessons from attacker perspective
- `$where` provides full JavaScript expression execution.
- `Object.keys(this)` reveals schema information.
- Blind regex-based brute forcing is highly effective.
- Reset tokens may be easier to extract than passwords.

### Lessons from AppSec perspective (defender)
- Sanitize and validate user input, using an allowlist of accepted characters.
- Insert user input using parameterized queries instead of concatenating user input directly into the query.
- To prevent operator injection, apply an allowlist of accepted keys.
- Use authentication libraries instead of handwritten DB queries.