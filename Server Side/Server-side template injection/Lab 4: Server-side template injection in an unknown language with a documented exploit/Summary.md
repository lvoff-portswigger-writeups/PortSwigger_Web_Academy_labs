## Lab Information

**Topic:** SSTI

**Difficulty:** Practitioner

**Template engine:** handlebars

**Language:** NodeJS

## Lab Description

The application uses Handlebars templates in a Node.js environment. Prototype access enables execution of arbitrary JavaScript code.

## Vulnerability Analysis

Although Handlebars is designed as a logic-less template engine, prototype manipulation allows attackers to reach JavaScript execution primitives.

## Exploitation Steps

### 1. Identify the injection point
??. Template behavior and syntax indicate the use of Handlebars in a Node.js environment.

### 2. Test for vulnerability
Fuzzing confirms execution of Handlebars expressions (despite the exact payload failed, we got the stack trace).

### 3. Craft the payload and execute the attack
Prototype manipulation is used to access the `Function` constructor.

### 4. Verify successful exploitation
A system command is executed via `child_process.exec`, deleting the target file. See Lab solved.

## AppSec Perspective

### **What the underlying code might be**

```javascript
// server.js
const express = require("express");
const handlebars = require("handlebars");

const app = express();
app.use(express.urlencoded({ extended: false }));

function renderPreview(userTemplate, context) {
  // Vulnerable pattern: untrusted template source is compiled at runtime.
  const tpl = handlebars.compile(userTemplate);
  return tpl(context);
}

app.post("/preview", (req, res) => {
  const userTemplate = String(req.body.template || "");

  const context = {
    user: req.user,
    product: { name: "Example", price: 100 },
  };

  const html = renderPreview(userTemplate, context);
  res.send(html);
});

module.exports = app;
```

### **Security issues enabling exploitation**
General issues:
* Untrusted input is incorporated into template rendering in a way that allows interpretation as template syntax (template injection).
* Template rendering occurs in a privileged server-side context with access to application objects and OS-level capabilities.
* Missing validation/encoding allows template metacharacters and expression delimiters to reach the interpreter.

Engine-specific issues:
* Prototype access is not restricted

### **How to fix it**
General recommendations:
* Avoid dynamic template construction
* Use strict variable substitution
* Escape and validate all user-controlled data

Engine-specific recommendations:
* Disable prototype access

## Key Takeaways

### Lessons from Attacker perspective

* Handlebars SSTI allows arbitrary JavaScript code execution without additional sandbox escape.
* JavaScript prototype chains are powerful
* Output visibility is not always required

### Lessons from AppSec (defender) perspective

* Template engines are programming languages, not formatting tools.
* User input must never influence template source code.
* SSTI is a design flaw, not an input validation bug.

## References

* [https://portswigger.net/web-security/server-side-template-injection](https://portswigger.net/web-security/server-side-template-injection)
* [https://handlebarsjs.com/](https://handlebarsjs.com/)
* [https://owasp.org/www-community/attacks/Server_Side_Template_Injection](https://owasp.org/www-community/attacks/Server_Side_Template_Injection)
* [https://github.com/handlebars-lang/handlebars.js/issues/1600](https://github.com/handlebars-lang/handlebars.js/issues/1600)