## **1. Initial Reconnaissance**

- Browsing the store normally, you open the product page for the *Lightweight l33t Leather Jacket*.
- In the browser’s developer tools (Network tab), you observe several API calls.
- The key request appears as:
    
    `GET /api/products/1/price`
    
    indicating an API endpoint that retrieves product prices dynamically.
    

Additional observed requests:

- `/product?productId=1` – regular page view
- `/cart` – shopping cart retrieval
    
    These suggest a partially decoupled frontend–backend architecture with API calls driving the UI.
    

---

## **2. Testing Methodology**

You begin by testing whether `/api/products/1/price` supports additional methods:

- Change the request from GET → PATCH.
- Add Content-Type: application/json.
- Provide a JSON body.

Many backends use shared controllers for handling CRUD operations. If the developer forgot to restrict methods, this might still be enabled.

## **3. Payload Construction**

You attempt the following PATCH request:

**Request**

```jsx
PATCH /api/products/1/price
Content-Type: application/json

{"price": 0}
```

You are testing two things:

1. **Does the server accept PATCH on this endpoint?**
2. **Is the JSON body parsed and applied?**

If the endpoint is misconfigured, it may directly update the price in the database.

---

## **4. Results and Observations**

The server responds successfully, confirming:

- PATCH is accepted.
- The price was updated.

Refreshing the product page now shows the price as **0.00**.

Next:

1. Add the jacket to the cart.
2. Go to /cart.
3. Complete the checkout.

The order processes successfully with a total of **0**, solving the lab.
