## Lab Information

**Topic:** API testing

**Difficulty:** Practitioner

## Lab Description

This lab contains an e-commerce checkout flow that processes purchase data via JSON submitted to `/api/checkout`. The backend performs object binding (deserializing JSON directly into server-side objects) without properly filtering which fields users are allowed to control.

Because of this, the API is vulnerable to **mass assignment**, allowing attackers to overwrite server-side fields such as discount percentage and manipulate the final price.

The goal is to exploit this flaw to buy the *Lightweight l33t Leather Jacket* for free.

## Vulnerability Analysis

The vulnerability is **Mass Assignment (aka Over-posting or Automatic Object Mapping Abuse)**.

Mass assignment happens when:

- The backend automatically maps JSON properties into backend model fields.
- No allowlist or denylist is implemented.
- Sensitive fields (e.g., `discount.percentage`) are not protected.
- The server trusts all user-supplied fields during deserialization.

In this lab, the checkout API accepts a JSON body like:

```json
{
  "chosen_products": [
    { "product_id": "1", "quantity": 1 }
  ]
}
```

But the server also processes additional properties if provided such as:

```json
"chosen_discount": { "percentage": 100 }
```

Because the price is calculated using both the product price and discount object, overwriting discount fields allows full price manipulation.

## Exploitation Steps

1. Observe various frontend requests:
    - `GET /cart`
    - `POST /cart` → basic cart operations
    - `GET /api/checkout` → shows current checkout info with discount structure
    - `POST /api/checkout` → takes JSON input that is mapped to backend objects
2. Inspect the response from GET /api/checkout and noticed this structure:

```json
{
  "chosen_discount": { "percentage": 0 },
  "chosen_products": [
    {
      "product_id": "1",
      "name": "Lightweight \"l33t\" Leather Jacket",
      "quantity": 1,
      "item_price": 133700
    }
  ]
}
```

3. Try manipulating product price directly:

```json
{
  "chosen_products": [
    {"product_id":"1","quantity":1,"item_price":0}
  ]
}
```

→ Does not work (server ignores this field).

4. Notice that chosen_discount.percentage looks user-controlled.
5. Submit the following:

```json
{
  "chosen_discount": { "percentage": 100 },
  "chosen_products": [
    { "product_id":"1", "quantity":1 }
  ]
}
```

6. The server applies a 100% discount, allowing the product to be purchased for free.

## AppSec Perspective

### **What the underlying code might look like**

A simplified backend implementation might look like:

```python
# Flask / Django-style pseudo-code
class CheckoutData:
    def __init__(self, chosen_products, chosen_discount):
        self.chosen_products = chosen_products
        self.chosen_discount = chosen_discount   # !dangerous!
        self.total_price = None

@app.post("/api/checkout")
def checkout():
    data = request.json

    # !Automatic mapping of all properties from user input!
    checkout_data = CheckoutData(**data)

    # !Using user-controlled values for discount calculation!
    discount = checkout_data.chosen_discount.percentage

    total = calculate_total(checkout_data.chosen_products)
    final_price = total * (1 - discount/100)

    process_payment(final_price)
    return {"status": "ok"}
```

### **Security issues enabling exploitation**

- **Automatic object mapping without filtering allowed fields.**
- **No allowlist of writable fields**.
- **User controls business-critical logic (discount).**
- **Hidden fields returned in GET response reveal attack surface**.
- **Backend trusts user-supplied price modifiers**.

### **How to fix it**

**Implement allowlisting (blacklisting is a bad practice)**

Only accept safe fields:

```python
allowed = {
    "chosen_products": sanitize_products(request.json["chosen_products"])
}
```

**Explicit parameter binding**

Avoid passing all user fields into model constructors.

**Server-side discount calculation**

Discounts must come ONLY from backend logic, not user input.

**Apply schema validation**

Using:

- Django serializers
- Marshmallow
- Pydantic
- JSON schema validation

**Never expose sensitive fields in GET responses**

API should not reveal:

- discount structures
- admin-only fields
- internal pricing logic
