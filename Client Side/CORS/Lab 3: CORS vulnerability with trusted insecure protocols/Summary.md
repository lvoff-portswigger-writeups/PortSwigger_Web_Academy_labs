# Lab 3: CORS vulnerability with trusted insecure protocols

## Lab Information

**Topic:** Cross-origin resource sharing (CORS)

**Difficulty:** Practitioner

## Lab Description

The application trusts all subdomains for CORS regardless of protocol and allows credentialed cross-origin requests. Additionally, a subdomain contains a client-side XSS vulnerability. By combining the permissive CORS configuration with the XSS flaw, sensitive information such as the administrator’s API key can be exfiltrated. The objective is to retrieve the administrator’s API key by exploiting this trust relationship.

## Vulnerability Analysis

It can be observed that the server reflects arbitrary subdomains in the `Access-Control-Allow-Origin` header while enabling credentials. A related subdomain contains a reflected XSS vulnerability in the `productId` parameter. By exploiting XSS on a trusted subdomain, malicious JavaScript executes within an origin accepted by the CORS policy. This enables credentialed access to `/accountDetails` and exfiltration of sensitive data.

## Exploitation Steps

1. Identify the injection point The `productId` parameter on the stock subdomain is vulnerable to reflected XSS.
2. Test for vulnerability Injected script payloads execute successfully within the subdomain context.
3. Craft the payload and execute the attack The victim is redirected to the vulnerable subdomain with a URL-encoded XSS payload that performs a credentialed request to `/accountDetails` and forwards the response to the exploit server.
4. Verify successful exploitation The exploit server log displays the administrator’s API key within the exfiltrated response.

## AppSec Perspective

### **What the underlying code might be**

A simplified backend implementation might look like:

```python
origin = request.headers.get("Origin")
if origin.endswith(".web-security-academy.net"):
    response.headers["Access-Control-Allow-Origin"] = origin
response.headers["Access-Control-Allow-Credentials"] = "true"
```

### **Security issues enabling exploitation**

- Trusting all subdomains without strict validation
- Lack of protocol enforcement in origin validation
- Credentialed cross-origin requests enabled for untrusted origins
- Exposure of sensitive data via CORS-accessible endpoints
- Allowing credentialed CORS requests
- Presence of exploitable XSS on a trusted subdomain

### **How to fix it**

- Implement a strict allowlist of trusted origins (including protocol validation)
- Explicitly reject the `null` origin
- Disable `Access-Control-Allow-Credentials` unless strictly required
- Restrict sensitive endpoints from cross-origin access
- Eliminate XSS vulnerabilities via proper input validation and output encoding
- Apply defense-in-depth controls such as Content Security Policy

## Key Takeaways

### Attacker perspective

- Chaining XSS with permissive CORS enables high-impact data exfiltration
- Trust relationships between subdomains can expand attack surface
- Misconfigured CORS enables authenticated data exfiltration
- Credentialed requests significantly increase impact severity

### AppSec (defender) perspective

- Origin validation must include exact scheme, host, and port matching
- Cross-domain trust assumptions require continuous security review
- CORS policies must follow least-privilege principles
- Sensitive endpoints should not be exposed to cross-origin reads

## References

- https://portswigger.net/web-security/cors
- https://owasp.org/www-community/attacks/CORS_OriginHeaderScrutiny
- https://owasp.org/www-community/attacks/xss/
- https://cheatsheetseries.owasp.org/cheatsheets/CORS_Configuration_Cheat_Sheet.html
- https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS